# sui-rpc-caller

* https://docs.sui.io/testnet/build/json-rpc

## 内存管理

内存管理一般分为几种

1. 手工控制 c c++ 完成手工控制
2. GC 机制的语言: java, golang
3. rust 这类 没有GC, 没有手工释放。 是通过所有权字段判断，自动释放。 人在值在

所用权规则和借用规则

1. 数据所有者有且仅有一个，并且决定数据生命周期
2. 引用可以有多个，但是，可变应用只能有一个

## 数据类型

1. 固定类型：基本类型，复合类型(数组，元组),指针类型 引用，裸指针 函数指针等
2. 动态类型：字符串类型 String ， 切片类型， trait object

赋值时候对应的变化:
固定类型复制所有权，动态类型转移所有权。

## 生命周期问题

其主要解决：当数据被销毁以后，引用还存在的矛盾，解决野指针的问题。
可参看代码及说明: [lifecycle.rs](./src/lifecycle.rs)


## trait

1. 类似接口，定义方法，类方法的标准
2. 泛型约束，缩小泛型的类型
3. 参数可以使用trait 来限制实现了某一个trait 的参数 Vector 中默认提供同类型，如果不同类型的struct 需要放到一个vector 中，可以使用一个 trait 来封装

## 其他

&str 本身是数据指针，并不拥有所指向的数据。 String 则拥有对应的数据。
所以 赋值 &str 的时候，其实是 数据指针的复制，同时指向相同的数据。
赋值 String 等其他的变量的时候，则会发生数据所有权的转移。
trait 的一个应用场景，可以定义 plugin 类型库。把plugin 的通用操作定义为 Trait ， 用户实现插件，即为实现trait . 最后，调用插件 则是通过 循环 插件库，触发trait 的方法。

trait 和所有权机制，独立存在。 trait 就是打开天窗说亮话，就是把所有权机制具体化了。

rust 使用内存的方式更符合人类认知，当使用者存在的时候，内存资源存在，当超出使用者作用范围的时候，即被释放。
