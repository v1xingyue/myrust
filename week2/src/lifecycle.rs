// 当函数执行完以后， s  就被销毁了，所以 ，返回的不可变引用就变成空指针，将无法访问
// pub fn hello() -> &u8 {
//     let s: u8 = 32;
//     s
// }

pub fn hello(x: &u8) -> &u8 {
    x
}

// 只有一个参数引用的时候，编译器可以识别并规定该内容比如返回为传入的引用，所以可以编译通过
// 但是当有多余两个参数的时候，编译器将无法识别返回数据的来源，就需要手工声明
// pub fn hello_2(a: &u8, b: &u8) -> &u8 {
//     a
// }

// 使用 'a ,'b 标识声明周期，用来告诉编译器，我返回的是哪个生命周期的变量
// 相同生命周期的参数可以包含多个
// str 的生命周期为 static ，即 和 进程同等生命周期
pub fn hello_lifecycle<'a, 'b>(_a: &'a u8, b: &'b u8, c: &'b u8) -> &'b u8 {
    b
}

// 生命周期参数，只是用于标记函数参数。
// 并不是规定，换句话说，我实际调用的时候，可以不按照定义的生命周期长短来传递参数
// 生命周期参数： life(a) >= life(b)
pub fn hello_3<'a: 'b, 'b>(a: &'a u8, b: &'b u8) -> &'b u8 {
    b
}
